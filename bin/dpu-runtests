#!/usr/bin/env python
# Copyright (c) DPU AUTHORS, under the terms and conditions of the GPL-2+
# license.

import sys
import time
import thread
import threading
import datetime as dt
import multiprocessing

from dpu.suite import TestSuite
from dpu.utils import mkdir, tmpdir


class LockedIterator(object):
    def __init__(self, it):
        self.lock = threading.Lock()
        self.it = it.__iter__()

    def __iter__(self):
        return self

    def next(self):
        self.lock.acquire()
        try:
            return self.it.next()
        finally:
            self.lock.release()

tsdir = "."
if len(sys.argv) > 1:
    tsdir = sys.argv[1]
ws = TestSuite(tsdir)
tests = LockedIterator(ws.tests())
cpu_count = multiprocessing.cpu_count()

had_failure = False
test_count = 0

t_count = (cpu_count * 2)
threads = []

class TestJob(threading.Thread):
    def __init__(self, iterator):
        self.iterator = iterator
        threading.Thread.__init__(self)

    def run(self):
        global had_failure
        global test_count
        for test in self.iterator:
            test_count += 1
            val = test.run()
            stat = [val[x] for x in val]
            if len(stat) == 0:
                sys.stdout.write(",")
            elif "failed" in stat:
                had_failure = True
                sys.stdout.write("F")
            else:
                sys.stdout.write(".")
            sys.stdout.flush()

started = dt.datetime.now()

for guy in range(0, t_count):
    t = TestJob(tests)
    threads.append(t)

for t in threads:
    t.start()
    time.sleep(0.1)

for t in threads:
    t.join()

ended = dt.datetime.now()

print ""
print "Ran %s tests in %s seconds" % (
    test_count,
    (ended - started).total_seconds()
)

if had_failure:
    sys.exit(1)
else:
    sys.exit(0)
